<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>GPT 로고 벽돌깨기</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #0b0e1a;
      color: #fff;
      font-family: system-ui, -apple-system, sans-serif;
    }
    h1 { margin-bottom: 10px; }
    .game-wrapper {
      position: relative;
      overflow: hidden;
      border-radius: 12px;
      box-shadow: 0 0 20px rgba(0,0,0,0.7);
    }
    canvas {
      display: block;
      background: #050818;
    }
    .center-text {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      color: white;
      font-size: 18px;
      text-shadow: 0 0 5px black;
      text-align: center;
      padding: 0 10px;
    }
  </style>
</head>

<body>
<h1>GPT 로고 벽돌깨기</h1>

<div class="game-wrapper">
  <canvas id="gameCanvas" width="800" height="900"></canvas>
  <div class="center-text" id="centerText">gpt_logo.png 로고 불러오는 중...</div>
</div>

<script>
/* =============================
      캔버스 및 기본 설정
============================= */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const centerText = document.getElementById("centerText");

let isRunning = false;
let ballStuck = true;

/* =============================
      패들 설정
============================= */
const ORIGINAL_PADDLE_WIDTH = 110;
const ENLARGED_PADDLE_WIDTH = 160;
const PADDLE_HEIGHT = 14;
const PADDLE_MARGIN_BOTTOM = 40;

let paddleWidth = ORIGINAL_PADDLE_WIDTH;
let paddleX = (canvas.width - paddleWidth) / 2;

let rightPressed = false;
let leftPressed = false;

let isPaddleEnlarged = false;
let paddleEnlargeEndTime = 0;

/* =============================
      공 설정
============================= */
const BALL_RADIUS = 8;
let balls = [];

/* =============================
      벽돌(로고 샘플링) 설정
============================= */

// 그리드 해상도 (값 올리면 벽돌 개수 ↑, 로고 더 부드러워짐)
const GRID_COLS = 60;
const GRID_ROWS = 60;

// 벽돌 크기
const BRICK_WIDTH = 10;
const BRICK_HEIGHT = 6;
const BRICK_PADDING = 2;

// 상단 쪽으로 올리기
const BRICK_OFFSET_TOP = 40;

// 나머지는 로고 로딩 후 결정됨
let BRICK_OFFSET_LEFT = 0;
let BRICK_COLS = GRID_COLS;
let BRICK_ROWS = GRID_ROWS;

// 로고에서 추출한 마스크 (true = 벽돌 놓을 자리)
let brickMask = null;

// 실제 벽돌 데이터
let bricks = [];
let bricksRemaining = 0;

/* =============================
      아이템 설정
============================= */
const ITEM_DROP_PROB = 0.2;
const ITEM_SIZE = 18;
const ITEM_FALL_SPEED = 2;

const ITEM_PLUS2 = "PLUS2";
const ITEM_MULT2 = "MULT2";
const ITEM_PADDLE = "PADDLE";

let items = [];

/* =============================
      초기화 함수
============================= */
function initPaddle() {
  paddleX = (canvas.width - paddleWidth) / 2;
}

function createBall() {
  const speed = 4;
  const angle = (Math.random() * 0.6 + 0.2) * Math.PI;
  return {
    x: paddleX + paddleWidth / 2,
    y: canvas.height - PADDLE_MARGIN_BOTTOM - PADDLE_HEIGHT - BALL_RADIUS,
    dx: speed * Math.cos(angle),
    dy: -Math.abs(speed * Math.sin(angle)),
    radius: BALL_RADIUS
  };
}

function resetBalls() {
  balls = [createBall()];
  ballStuck = true;
}

/* =============================
      로고 이미지 → 벽돌 마스크 생성
============================= */
function createBrickMaskFromImage(img) {
  const off = document.createElement("canvas");
  off.width = GRID_COLS;
  off.height = GRID_ROWS;
  const octx = off.getContext("2d");

  // 로고를 위쪽에 맞춰서 그리드에 맞게 스케일링
  const scale = Math.min(GRID_COLS / img.width, GRID_ROWS / img.height);
  const drawW = img.width * scale;
  const drawH = img.height * scale;
  const dx = (GRID_COLS - drawW) / 2; // 가운데 정렬
  const dy = 0; // 위쪽으로 붙이기

  octx.clearRect(0, 0, GRID_COLS, GRID_ROWS);
  octx.drawImage(img, dx, dy, drawW, drawH);

  const data = octx.getImageData(0, 0, GRID_COLS, GRID_ROWS).data;

  brickMask = [];
  for (let y = 0; y < GRID_ROWS; y++) {
    brickMask[y] = [];
    for (let x = 0; x < GRID_COLS; x++) {
      const idx = (y * GRID_COLS + x) * 4;
      const r = data[idx];
      const g = data[idx + 1];
      const b = data[idx + 2];
      const a = data[idx + 3];

      const brightness = 0.299 * r + 0.587 * g + 0.114 * b;

      // 배경(흰색) 제외, 검은 선 부분만 벽돌로
      const isBrick = a > 10 && brightness < 230;
      brickMask[y][x] = isBrick;
    }
  }

  // 가로 위치 가운데 정렬
  const totalWidth = GRID_COLS * (BRICK_WIDTH + BRICK_PADDING);
  BRICK_OFFSET_LEFT = (canvas.width - totalWidth) / 2;
  BRICK_COLS = GRID_COLS;
  BRICK_ROWS = GRID_ROWS;
}

/* =============================
      벽돌 배열 초기화 (마스크 기반)
============================= */
function initBricks() {
  bricks = [];
  bricksRemaining = 0;

  if (!brickMask) return;

  for (let row = 0; row < BRICK_ROWS; row++) {
    bricks[row] = [];
    for (let col = 0; col < BRICK_COLS; col++) {
      if (!brickMask[row][col]) {
        bricks[row][col] = null;
        continue;
      }
      const x = BRICK_OFFSET_LEFT + col * (BRICK_WIDTH + BRICK_PADDING);
      const y = BRICK_OFFSET_TOP + row * (BRICK_HEIGHT + BRICK_PADDING);
      bricks[row][col] = { x, y, status: 1 };
      bricksRemaining++;
    }
  }
}

function resetGame() {
  paddleWidth = ORIGINAL_PADDLE_WIDTH;
  isPaddleEnlarged = false;
  items = [];
  initPaddle();
  initBricks();
  resetBalls();
  isRunning = false;
  ballStuck = true;
  centerText.textContent = "Space 또는 클릭해서 시작";
  centerText.style.opacity = "1";
}

/* =============================
      그리기
============================= */
function drawPaddle() {
  ctx.fillStyle = "#39c6ff";
  const y = canvas.height - PADDLE_MARGIN_BOTTOM - PADDLE_HEIGHT;
  ctx.fillRect(paddleX, y, paddleWidth, PADDLE_HEIGHT);
}

function drawBalls() {
  for (const b of balls) {
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
    ctx.fillStyle = "#ff2d8d";
    ctx.fill();
    ctx.closePath();
  }
}

function drawBricks() {
  if (!bricks.length) return;
  for (let r = 0; r < bricks.length; r++) {
    const row = bricks[r];
    if (!row) continue;
    for (let c = 0; c < row.length; c++) {
      const b = row[c];
      if (!b || b.status === 0) continue;

      ctx.fillStyle = `hsl(${(r + c) * 4}, 70%, 50%)`;
      ctx.fillRect(b.x, b.y, BRICK_WIDTH, BRICK_HEIGHT);
    }
  }
}

function drawItems() {
  for (const it of items) {
    if (!it.active) continue;
    let color = "#fff", text = "";

    if (it.type === ITEM_PLUS2)  { color = "#ffee00"; text = "+2"; }
    if (it.type === ITEM_MULT2) { color = "#ff0059"; text = "x2"; }
    if (it.type === ITEM_PADDLE){ color = "#00aaff"; text = "P";  }

    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(it.x, it.y, ITEM_SIZE / 2, 0, Math.PI * 2);
    ctx.fill();
    ctx.closePath();

    ctx.fillStyle = "#000";
    ctx.font = "10px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text, it.x, it.y);
  }
}

/* =============================
      아이템 처리
============================= */
function maybeDropItem(x, y) {
  if (Math.random() > ITEM_DROP_PROB) return;

  const types = [ITEM_PLUS2, ITEM_MULT2, ITEM_PADDLE];
  items.push({
    x,
    y,
    type: types[Math.floor(Math.random() * types.length)],
    active: true,
    vy: ITEM_FALL_SPEED
  });
}

function updateItems() {
  const paddleTop = canvas.height - PADDLE_MARGIN_BOTTOM - PADDLE_HEIGHT;

  for (const it of items) {
    if (!it.active) continue;

    it.y += it.vy;

    if (
      it.y + ITEM_SIZE / 2 >= paddleTop &&
      it.x >= paddleX &&
      it.x <= paddleX + paddleWidth
    ) {
      applyItemEffect(it.type);
      it.active = false;
    }

    if (it.y > canvas.height + ITEM_SIZE) it.active = false;
  }

  items = items.filter(i => i.active);
}

function applyItemEffect(type) {
  if (balls.length === 0) return;
  const base = balls[0];

  if (type === ITEM_PLUS2) {
    spawnExtraBalls(base, 2);
  } else if (type === ITEM_MULT2) {
    const snapshot = [...balls];
    for (const b of snapshot) {
      spawnExtraBalls(b, 1);
    }
  } else if (type === ITEM_PADDLE) {
    enlargePaddle();
  }
}

function spawnExtraBalls(base, count) {
  const speed = Math.sqrt(base.dx ** 2 + base.dy ** 2);
  const baseAngle = Math.atan2(base.dy, base.dx);
  const spread = 10 * Math.PI / 180;

  for (let i = 0; i < count; i++) {
    const angle = baseAngle + (i === 0 ? -spread : spread);
    balls.push({
      x: base.x,
      y: base.y,
      dx: speed * Math.cos(angle),
      dy: speed * Math.sin(angle),
      radius: BALL_RADIUS
    });
  }
}

/* =============================
      패들 버프
============================= */
function enlargePaddle() {
  const center = paddleX + paddleWidth / 2;
  paddleWidth = ENLARGED_PADDLE_WIDTH;
  paddleX = center - paddleWidth / 2;
  paddleX = Math.max(0, Math.min(paddleX, canvas.width - paddleWidth));

  isPaddleEnlarged = true;
  paddleEnlargeEndTime = Date.now() + 5000;
}

function updatePaddleEnlarge() {
  if (!isPaddleEnlarged) return;
  if (Date.now() > paddleEnlargeEndTime) {
    const center = paddleX + paddleWidth / 2;
    paddleWidth = ORIGINAL_PADDLE_WIDTH;
    paddleX = center - paddleWidth / 2;
    isPaddleEnlarged = false;
  }
}

/* =============================
      공 업데이트
============================= */
function updateBalls() {
  if (ballStuck) {
    const b = balls[0];
    b.x = paddleX + paddleWidth / 2;
    b.y = canvas.height - PADDLE_MARGIN_BOTTOM - PADDLE_HEIGHT - BALL_RADIUS;
    return;
  }

  const alive = [];
  for (const ball of balls) {
    // 벽
    if (ball.x + ball.dx < ball.radius || ball.x + ball.dx > canvas.width - ball.radius)
      ball.dx *= -1;
    if (ball.y + ball.dy < ball.radius)
      ball.dy *= -1;

    handlePaddleCollision(ball);
    handleBrickCollision(ball);

    ball.x += ball.dx;
    ball.y += ball.dy;

    if (ball.y < canvas.height + ball.radius) alive.push(ball);
  }

  balls = alive;

  if (balls.length === 0) {
    gameOver();
  }
}

function handlePaddleCollision(ball) {
  const top = canvas.height - PADDLE_MARGIN_BOTTOM - PADDLE_HEIGHT;
  if (
    ball.y + ball.radius >= top &&
    ball.x >= paddleX &&
    ball.x <= paddleX + paddleWidth &&
    ball.dy > 0
  ) {
    const hitPos = (ball.x - (paddleX + paddleWidth / 2)) / (paddleWidth / 2);
    const angle = hitPos * (75 * Math.PI / 180);
    const speed = Math.sqrt(ball.dx ** 2 + ball.dy ** 2);

    ball.dx = speed * Math.sin(angle);
    ball.dy = -Math.abs(speed * Math.cos(angle));
  }
}

function handleBrickCollision(ball) {
  if (!bricks.length) return;
  for (let r = 0; r < bricks.length; r++) {
    const row = bricks[r];
    if (!row) continue;
    for (let c = 0; c < row.length; c++) {
      const b = row[c];
      if (!b || b.status === 0) continue;

      if (
        ball.x > b.x &&
        ball.x < b.x + BRICK_WIDTH &&
        ball.y > b.y &&
        ball.y < b.y + BRICK_HEIGHT
      ) {
        ball.dy *= -1;
        b.status = 0;
        bricksRemaining--;

        maybeDropItem(b.x + BRICK_WIDTH / 2, b.y);

        if (bricksRemaining <= 0) {
          isRunning = false;
          centerText.textContent = "GPT 로고 올 클리어! Space / 클릭으로 다시 시작";
          centerText.style.opacity = "1";
        }
        return;
      }
    }
  }
}

/* =============================
      메인 루프
============================= */
function updatePaddle() {
  if (rightPressed) paddleX += 6;
  if (leftPressed)  paddleX -= 6;

  paddleX = Math.max(0, Math.min(paddleX, canvas.width - paddleWidth));
}

function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawBricks();
  drawPaddle();
  drawBalls();
  drawItems();

  if (isRunning) {
    updatePaddle();
    updateBalls();
    updateItems();
    updatePaddleEnlarge();
  }

  requestAnimationFrame(gameLoop);
}

/* =============================
      입력 처리
============================= */
document.addEventListener("keydown", e => {
  if (e.code === "ArrowRight") rightPressed = true;
  if (e.code === "ArrowLeft")  leftPressed = true;
  if (e.code === "Space")      startGame();
});
document.addEventListener("keyup", e => {
  if (e.code === "ArrowRight") rightPressed = false;
  if (e.code === "ArrowLeft")  leftPressed = false;
});

/* 마우스 이동 */
document.addEventListener("mousemove", e => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const scaleX = canvas.width / rect.width;
  const canvasX = mouseX * scaleX;

  paddleX = canvasX - paddleWidth / 2;
  paddleX = Math.max(0, Math.min(paddleX, canvas.width - paddleWidth));
});

canvas.addEventListener("click", startGame);
centerText.addEventListener("click", startGame);

function startGame() {
  // 클리어 후 다시 시작
  if (!isRunning && bricksRemaining <= 0) {
    resetGame();
  }
  // 게임 오버 후 다시 시작
  if (!isRunning && balls.length === 0) {
    resetGame();
  }
  ballStuck = false;
  isRunning = true;
  centerText.style.opacity = "0";
}

function gameOver() {
  isRunning = false;
  centerText.textContent = "게임 오버! Space / 클릭으로 재시작";
  centerText.style.opacity = "1";
  // 공은 비워둔다. startGame에서 resetGame 호출.
  balls = [];
}

/* =============================
      로고 이미지 로드 후 게임 시작
============================= */
function loadLogoAndStart() {
  const img = new Image();
  img.src = "gpt_logo.png"; // 같은 폴더에 이 이름으로 저장해두기

  img.onload = () => {
    createBrickMaskFromImage(img);
    resetGame();
    centerText.textContent = "Space 또는 클릭해서 시작";
    gameLoop();
  };

  img.onerror = () => {
    centerText.textContent =
      "gpt_logo.png 로고를 같은 폴더에 넣어야 합니다.";
    console.error("gpt_logo.png 파일을 찾을 수 없습니다.");
    // 그래도 게임 루프는 돌려둠 (벽돌 없이)
    gameLoop();
  };
}

loadLogoAndStart();
</script>

</body>
</html>
